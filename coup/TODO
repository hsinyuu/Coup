Requirements:
- Support room creation
- Room chat
- Ping player to check if connection is alive
- Game related:
    - Receive player's action
    - Verify player action (Cheat detection)
    - Update and broadcast game state
    - Control turns

Bug Fixes:
[ ] Dead player still selectable for target
[ ] Self player selectable as target
[ ] Coins going negative
[X] Lose influence selectable dead influence
[X] Exchange cards. Need to rethink how I do influence select.

Features:
[ ] Timer bar
[ ] Room select

Frontend:
// These are the fundamental prototype functionality I should have in order to demo the game
- Lobby
    [ ] List of rooms
    [ ] Create room
    [ ] Join room
    [ ] Delete room if master
    [ ] Assign random username
- Room
    [X] Self player highlight
    [X] Turn player highlight
    [X] Show player influence
    [X] Show player status (observer or player)
    [X] Player name
    [X] Send player moves
    [X] Chatbox
    [X] Input chat
    [X] Players in the room
    [X] Buttons for actions/counteractions/challenge

Backend:
[X] Define exceptions
[X] Proper logging support
[X] PlayerConsumer
    [ ] Redefinition of message handling
    [X] Update game state
    [X] Send GameMessage
    [X] Send message type (by player, game msg, etc.)
    [X] Receive ChatMessage
    [X] Receive Actions
    [X] Send ChatMessage
[X] RoomManagerConsumer
    [X] Create a new coup game with respect to room
    [X] Receive Actions
    [X] Each turn, we send current state of the game
    [X] Keep multiple games in cache; probably in a form of dict
    [X] Setup worker
[X] CoupGame
    [ ] Move timer
    [X] Game logic
        [X] Coup kill
        [X] Ambassador exchange
        [X] Coins increment
        [X] Assassin kill
        [X] Influence logic at challenge (lose or exchange)
        [X] Move player to observer once both influences are dead
    [X] Player status update (influence, coin and alive/dead)
    [X] Valid move getter
    [X] Game state definitions
    [X] Action/counteraction/influence definitions
    [X] Decide on datastructure
    [X] Define tests


##Messages
Server to client message structure
{
    'header': 'player-states',
    'message': [
        {
            'player-name': 'player0',
            'playing': true,
            'influence': ['Duke', 'Assassin']
            'coin': 0
        },
        {
            'player-name': 'player1',
            'playing': true,
            'influence': ['*', '*']
            'coin': 0
        }
    ]
}
{
    'header': 'chat-message',
    'message':'new chat message'
}
{
    'header':' 'player-valid-moves',
    'message': ['action-income', 'action-foreign-aid', ...]
}

Client to server message structure
There are three types of headers:
    - chat-message  : chat message to the group
    - game-control  : utilities in the game such as start or pause
    - game-move     : actual gameplay
{
    'header': 'chat-message',
    'message': 'hello guys'
}
{
    'header': 'game-control',
    'message': 'start-game'
}
{
    'header': 'game-control',
    'message': 'exit'
}
{
    'header': 'game-control',
    'message': 'pause'
}
{
    'header': 'game-move',
    'message': {
        'type': 'action',
        'move': 'income',
        'target': null
    }
}
{
    'header': 'game-move',
    'message': {
        'type': 'action',
        'move': 'assassinate',
        'target': 'player2'
    }
}
{
    'header': 'game-move',
    'message': {
        'type': 'counteraction',
        'move': 'block-foreign-aid',
        'target': null
    }
}
{
    'header': 'game-move',
    'message': {
        'type': 'challenge',
        'move': 'challenge',
        'target': null
    }
}

Server internal
GameEngineConsumer:
    def player_move_event():
        # Receives player move and return sanitized type for the entity
    def player_control_event():
        # Receives player control and broadcast the required updates to the players in the room